#include <iostream>
using namespace std;

class AVLNode {
public:
    int data;
    AVLNode* left;
    AVLNode* right;
    int height;
    
    AVLNode(int val) {
        data = val;
        left = right = nullptr;
        height = 1;
    }
};

class AVLTree {
private:
    AVLNode* root;
    
    int height(AVLNode* node) {
        if (node == nullptr) return 0;
        return node->height;
    }
    
    int balance(AVLNode* node) {
        if (node == nullptr) return 0;
        return height(node->left) - height(node->right);
    }
    
    AVLNode* rightRotate(AVLNode* y) {
        AVLNode* x = y->left;
        AVLNode* T2 = x->right;
        
        x->right = y;
        y->left = T2;
        
        y->height = max(height(y->left), height(y->right)) + 1;
        x->height = max(height(x->left), height(x->right)) + 1;
        
        return x;
    }
    
    AVLNode* leftRotate(AVLNode* x) {
        AVLNode* y = x->right;
        AVLNode* T2 = y->left;
        
        y->left = x;
        x->right = T2;
        
        x->height = max(height(x->left), height(x->right)) + 1;
        y->height = max(height(y->left), height(y->right)) + 1;
        
        return y;
    }
    
    AVLNode* insert(AVLNode* node, int x) {
        if (node == nullptr) return new AVLNode(x);
        
        if (x < node->data) node->left = insert(node->left, x);
        else if (x > node->data) node->right = insert(node->right, x);
        else return node;
        
        node->height = 1 + max(height(node->left), height(node->right));
        
        int bal = balance(node);
        
        // Left Left
        if (bal > 1 && x < node->left->data) return rightRotate(node);
        
        // Right Right
        if (bal < -1 && x > node->right->data) return leftRotate(node);
        
        // Left Right
        if (bal > 1 && x > node->left->data) {
            node->left = leftRotate(node->left);
            return rightRotate(node);
        }
        
        // Right Left
        if (bal < -1 && x < node->right->data) {
            node->right = rightRotate(node->right);
            return leftRotate(node);
        }
        
        return node;
    }
    
    AVLNode* search(AVLNode* node, int x) {
        if (node == nullptr || node->data == x) return node;
        
        if (x < node->data) return search(node->left, x);
        else return search(node->right, x);
    }
    
    void inorder(AVLNode* node) {
        if (node != nullptr) {
            inorder(node->left);
            cout << node->data << "(" << balance(node) << ") ";
            inorder(node->right);
        }
    }
    
public:
    AVLTree() {
        root = nullptr;
    }
    
    void insert(int x) {
        root = insert(root, x);
    }
    
    bool search(int x) {
        return search(root, x) != nullptr;
    }
    
    void display() {
        cout << "AVL Tree (with balance): ";
        inorder(root);
        cout << endl;
    }
};

int main() {
    AVLTree avl;
    
    avl.insert(10);
    avl.insert(20);
    avl.insert(30);
    avl.insert(40);
    avl.insert(50);
    avl.insert(25);
    
    avl.display();
    
    cout << "Search 30: " << (avl.search(30) ? "Found" : "Not found") << endl;
    cout << "Search 100: " << (avl.search(100) ? "Found" : "Not found") << endl;
    
    return 0;
}
